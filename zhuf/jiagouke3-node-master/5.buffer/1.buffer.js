// global上的重要属性 Buffer buffer代表的是内存

// 计算机存储数据 二进制来存储的 01 来表示
// 早期js没有读取数据的能力（文件读写） fs模块可以进行文件的读写。 node为了能展现文件的内容，就采用了Buffer这种格式 展现形式是16进制 可以和字符串相互转化

// 掌握基本的进制转化  如何实现一个base32数据格式 

// 2进制  0b开头  8进制0o   10进制   16进制 0x


// 1.如何将10进制转换成其他进制 50 -> 8进制 我们要对 8 取余数 最终的结果就是转化后的结果 （针对的是整数情况）

// 2.小数如何转化 0.1 + 0.2为什么不等于0.3  我们计算机计算的时候要将10进制转换成2进制

// 10      2
// 0.5 => 转化成2进制是多少  0.1  按照*2 取整法来计算  0.1  近似值相加 发现比以前大 。就无法正常运算了

// 0.00011000110001100011......
// 0.1 * 2 = 0.2  => 0
// 0.2 * 2 = 0.4  => 0
// 0.4 * 2 = 0.8  => 0
// 0.8 * 2 = 0.6  => 1
// 0.6 * 2 = 0.2  => 1


// 0.1 => 转化成2进制是多少 



// 如何把其他进制转换成10进制  公式
// 二进制数据 单位最小的叫bit位   1k = 1024字节  1个字节 = 8个位
// 当前位上的值 * 当前进制^(所在的位数)累加就是结果

console.log(parseInt('100', 2)); // 将二进制中的100 转换成10进制
console.log((0x16).toString(2)); // 将任意进制转换成任意进制  toString中传入数字表示转换成对应的进制

// 数字后面跟一个点 表示是数字的小数部分
console.log((100).toString(16));


// base64编码 -》 base32 是如何实现的 

// base64用来干嘛的？ 传递有价值 我们的数据不能用中文来进行传递 （乱码）  base64 可以用在所有的连接处 减少请求 （是否都要把图片转化成base64  把内容转化成base64之后 数据会比之前大1/3）

let str = '珠'; // -> base64编码  含义是转化出字节的大小不能超过64  一个字节8个位，不超过64的8个位最大是多少  最大是6个1 不超过64

// node默认支持utf8格式 utf8中一个汉字 是三个字节  三个字节是 3* 2 = 24个位 需要把汉字每6个位进行分割

console.log(Buffer.from('珠')); // e7 8f a0  16进制中最大值是ff  8个1最大是255  15 * 15    

console.log((0xe7).toString(2))
console.log((0x8f).toString(2))
console.log((0xa0).toString(2)) // 先将汉字 转化成 3 * 8的格式


console.log(parseInt('111001', 2)) // 在将3* 8 的格式转化成 4 * 6格式
console.log(parseInt('111000', 2))
console.log(parseInt('111110', 2))
console.log(parseInt('100000', 2)) // 57 56 62 32

// base64就是一种编码格式

let str1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
str1 += str1.toLowerCase();
str1 += '0123456789+/'; // 64  0-63 

console.log(str1[57] + str1[56] + str1[62] + str1[32]); // 54+g -》  珠 目的就是编码 没有加密的功能

// 怎么实现一个base32格式


// 1.commonjs的实现原理 webpack模块原理一样
// 2.内置模块 events模块 发补订阅的实现
// 3.global中的常用属性和方法 node中的事件环  process.nextTick  setImmediate 宏任务
// 4.npm的使用 安装包 实现全局包 版本控制
// 5.node中的编码怎么玩

// 下周 buffer ->  fs  -> 流 -> tcp/http