// Buffer 也是global上的属性可以直接访问
// 为什么要有Buffer?  早期js使用在浏览器中的 （不能操作文件 不能读写） node中需要去有读写文件能力的。 这就需要拥有一个能处理二进制的东西

// 文件读取出的内容 表现形式 （底层都是二进制）展现的形式不同 按照不同的编码展现给我

// Buffer可以用来描述内存中的内容 （二进制数据  =》 16进制）  http 流

// 进制转换  2进制 最大的是1  16进制最大的是15  

// 8个bit (二进制)  1字节b   1024b -> k 1024k -> 1M  1024m -> 1g

// 二进制转化成十进制 可以累加计算    1* 2^0 + 1 * 2^1 + .... 1* 2^7

let sum = 0;
for (let i = 0; i < 8; i++) {
    sum += 2 ** i
}
console.log(sum, 2 ** 8 - 1); // 1111111 -> 255

// 0.1 + 0.2 为什么 不等于0.3 存储的时候会被转化成2进制数据
// 如何将小数 转换成 二进制

// 0.5 在二进制中是多少   0.1  (2^-1)  归纳出把小数变成整数的方法 成2取整法
// 10 : 0.5 = 2 : x

// 0.5 => 1.0 = 1 -> 0.1  0.2+0.2 js运算 是一个近似值的运算 所有的小数运算都会有类似的问题 。 (计算的时候 有的近似值就是正确的，有的是非正确的)
// 0.1 -> 0.2 = 0
// 0.2 -> 0.4 => 0
// 0.4 -> 0.8 => 0
// 0.8 -> 0.6 => 1
// 0.6 -> 0.2 => 1
// 0.0001100110011001100110011001100110011001100110011001101
// 0.001100110011001100110011001100110011001100110011001101


// 如何将十进制转换成2进制
// base64编码也是这样实现

// ob开头的是 2进制 0x开头的是16进制  0o开头是8进制
console.log(parseInt('1010', 2)); // 85
console.log(0x40.toString(2)); // 可以将任何进制转换成任何进制 缺陷就是输出的是字符串



// 什么叫base64 ？ 转化后的每一个字节都是小于64的  （阿里 自己实现一个base32编码）


// utf8编码中规定了一个汉字3个字节 在gbk编码中1个汉字2字节
console.log(Buffer.from('珠')); // e7 8f a0  node默认只支持utf8格式 1个汉字就是3个字节 

// e7 8f a0

console.log(0xe7.toString(2)); 
console.log(0x8f.toString(2)); 
console.log(0xa0.toString(2)); 

// 11100111 10001111 10100000  3 * 8的格式  转化出的每个字节 不得大于64


// 3 * 8格式 改成 4 * 6的格式
//  00111001   00111000  00111110   00100000     3 -> 4 比之前大了1/3  （base64的缺陷）

console.log(parseInt('00111001',2))
console.log(parseInt('00111000',2))
console.log(parseInt('00111110',2))
console.log(parseInt('00100000',2))

// 57 56 62 32  编码 -》 解码 64的编码规范
let str1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
str1+= str1.toLowerCase();  //  26 * 2 + 12
str1+='0123456789+/'
console.log(str1[57] + str1[56] + str1[62] + str1[32]); // 54+g

// base64 并不是加密算法  编码规则是公开的。  对称 非对称

// 5张2块的
// 1张十块的

