## 浏览器的事件环 
关心我们的异步任务是怎样执行的， 定时器 ajax  底层还是基于多线程模型

> 计算机调度任务的基本单位都是以进程单位 （进程中包含着线程）

## 浏览器是一个多进程模型
浏览器每一个页卡都是一个进程  （整个主界面）
- 渲染进程 （执行js 引擎 执行绘制ui线程）
- 网络进程 存储 请求
- 插件
- gpu进程

渲染进程: (js线程 ui渲染线程  互斥， js"主线程"是单线程的  单线程阻塞) 
为什么js不设计成多线程模型， （1个线程说删掉dom元素） （另一个说要追加一个）  页面渲染和js 也是互斥的 （正在执行js的时候 可能需要删除dom ， 页面就不需要渲染这个节点）

webworker 创建的叫工作线程 （计算，不能操作dom） 


## js特点是单线程异步的 (异步任务进行分类， 底层实现肯定基于线程的)
> 事件触发线程
宏任务: 执行js脚本是一个宏任务， ui渲染  ajax， 定时器，事件， MessageChannel, setImmediate 宏任务队列 “队列只用有一个”
微任务: promise mutationObserver

> 宏任务队列只有一个（消息队列，宏任务队列）

> 每执行一轮


## node是啥？
- 就是js的一个运行时 ，可以让js运行在服务端 （js由什么组成 3部分 BOM DOM EC , NODE中不能使用BOM和DOM 只有ECMASCRIPT + 内置的模块 自己写的功能 + 第三方模块）

- node 依旧是“主线程是”单线程的  （通常情况下 单线程 好处就是如果做的事简单 并发量高）


类似于java，php 多线程同步模型 （感觉可以一起做多件事） 会浪费很多线程(内存) 可以利用线程池来优化. 对于多线程而言 操作同一个资源会有锁的问题  (多线程感觉是一起执行 对于单核cpu而言) 通过切换时间片达到同时执行  （优点就是：适合cpu密集型）  


对于node而言 单线程模型  如果是这种（I/O密集型 比较适合） 通常情况下 好处是异步非阻塞


异步同步 指的是调用方法的本身 （被调用方决定是不是异步）  fs.readFile writeFile 异步api
阻塞和非阻塞指代的就是调用方的状态  


> 处理高并发 nginx 单线程非阻塞处理


------------------------------------------------------------------------
》 node一般做中间层  服务端渲染  前端有工具webpack   服务端接口


## node的基本用法 
>  node版本16.11.0