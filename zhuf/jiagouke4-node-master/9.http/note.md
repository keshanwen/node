七层网络协议  （理想情况下的分层）  
- 应用层 
- 表示层 
- 会话层    ->  应用层  http

- 传输层    -> TCP / UDP
- 网络层    -> ip 

- 数据链路层 -> 交换机 集线器  -> 物理层  
- 物理层 网线 同轴电缆 


> 下层是为了上层服务的  HTTP应用层 （header头）  数据传递怎么去传递数据和解析数据。


mac地址 （固定的） ip地址 （可变的）  mac地址可以定位到具体的位置 来进行数据的传输  在出厂网卡的时候 会给你分配一个mac地址 (自己做的唯一 ，原则上唯一不可以更改)
最终通信都是通过mac地址 mac地址比较长 -》 ip来表示 -》 通过ip来进行寻址mac地址


## 客户端访问服务端的基本流程
- 用户会输入一个网址  通过DNS解析服务端找到对应的ip地址
- 需要将数据传递给对方  http中存的是报文 （ 请求行 请求头 请求体）
- tcp来发送数据   对数据进行拆包 而且添加了序号 （为了服务器收到之后可以进行数据的重组） 端口号 （tcp严重的缺陷队头阻塞，如果没有收到队头的数据，不会发送后续的内容）
- 发送的时候 需要通过ip地址进行寻址操作  边转发边发送  经历多个路由器  发快递 北京 -> 南京 -》 杭州 -》 上海  （路由）
- 对方会根据 我们的数据进行重组 将数据拼接起来  最终服务器会响应客户端说 数据收到了  （响应行， 响应头，响应体）

 
## http缺陷 `1.1` 
- 安全问题 在传输中明文传输 （http 现在使用最多的就是1.1 ）  明文就会被别人篡改 对方也不知道这个数据有被更改过  tls 来保证数据的可靠。 通过证书来保证数据不被篡改  https 就解决了 http的问题
- http 1.1 也有个缺陷就是 基于tcp的 tcp层面上有一个队头阻塞问题。 http1.1 本身就有这个问题  （tcp面向连接  慢 三次握手和四次断开）


## 中新增的特点  1.0 -》 1.1
- 1.0 缺陷就是只能发送get请求， 而且不支持除了文本之外的内容 图片，css都不支持   
- 1.0 发送的时候会创建tcp连接 发送完毕后就关闭了  性能浪费
- 不能识别访问者的身份


## 1.1解决的方式 
- 添加了除了get之外的其他请求方法， 增加了请求头的概念 （发送除文本之外的内容）
- 长连接的方式 解决发送时创建多个tcp的问题，  在一段时间内可以复用tcp通道
- 为了可以处理多个请求同时发送，内部还有管线化的特点  （ 可以在一个tcp中发送多个请求 ，问题是响应的时候 需要根据顺序来响应， 依然会有队头阻塞的问题  指的是http中的队头阻塞） 在2.0中被解决了 ， tcp的队头阻塞是tcp本身的 所以http2 也无法解决 
- cookie 增加了cookie机制 可以用于识别用户身份 xsrf



## HTTP方法
- GET / POST / PUT /DELETE  增删改查  options 跨域的时候发送 预检请求 
- Resful风格   

get /user  查询用户
post /user  添加用户
PUT /user  修改


options表示跨域的时候 会先检测是否ok ？ ok的话再去发送具体的数据 
复杂请求才会发送options，常见的基本get和post就是简单请求，添加了自定义的头部就变成了了复杂请求了  只在跨域的时候使用

##错误  502网关错误   503 服务端负载均衡挂掉了。 HTTP状态码  （服务端响应的状态码 服务端响应的）  状态服务端可以随便写
1xx  101 websocket
2xx  200 ok  204 成功但是没有响应内容 206范围请求
3xx  301  永久重定向 （在开发的时候尽可能减少重定向） 302 （临时重定向 ， 客户端跳转了） 304 缓存 （面试常问 对比缓存，如果文件没有变化就用缓存）  307 只能用get重定向 
4xx  400 客户端访问不正确  404 找不到 401 没有认证权限  403 认证了还是没权限  405 方法服务端不存在 
5xx  服务端问题 500 服务端内部